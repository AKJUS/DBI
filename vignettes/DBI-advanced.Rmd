---
title: "Advanced DBI Usage"
author: "James Wondrasek"
date: "17/03/2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"Advanced DBI Usage"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(error = (getRversion() < "3.5"))

knit_print.data.frame <- function(x, ...) {
  print(head(x, 3))
  if (nrow(x) > 3) {
    cat("Showing 3 out of", nrow(x), "rows.\n")
  }
  invisible(x)
}

registerS3method("knit_print", "data.frame", "knit_print.data.frame")
```

## Who this tutorial is for

This tutorial is for you if you need to use a richer set of SQL features such as data manipulation queries, parameterised queries and queries performed using SQL's transaction features.

## How to run more complex queries using DBI

`dbGetQuery()` works by calling a number of functions behind the scenes. 
If you need more control, you can manually build your own query, retrieve results at your selected rate, and release the resources involved, by calling the same functions.

These functions are:
`dbSendQuery()` - sends the SQL query to the DBMS and returns a `result` object.
The query is limited to `SELECT` statements.
If you want to send other statements, such as `INSERT`, `UPDATE`, `DELETE`, etc, use `dbSendStatement()`.

`dbFetch()` - is called with the `result` object returned by `dbSendQuery()`.
It also accepts an argument specifying the number of rows to be returned, eg `n=200`.
If you want to fetch all the rows, use `n=-1`.

`dbClearResult()` - is called when you have finished retrieving data.
It releases the resources associated with the `result` object.

```{r}
library(DBI)

con <- dbConnect(RMariaDB::MariaDB(), username = "guest", password = "relational", host = "relational.fit.cvut.cz", port = 3306, dbname = "sakila")
res <- dbSendQuery(con, "SELECT * FROM film WHERE rating = 'G'")
df <- dbFetch(res)
dbClearResult(res)
head(df,3)
```

## How to read part of a table from a database

If your dataset is large you may want to fetch a limited number of rows at a time.
As demonstrated below, this can be accomplished by using a while loop where the function `dbHasCompleted()` is used to check for ongoing rows, and `dbFetch()` is used with the `n = X` argument, specifying how many rows to return on each iteration.
Again, we call `dbClearResult()` at the end to release resources. 

```{r}

res <- dbSendQuery(con, "SELECT * FROM film")
while(!dbHasCompleted(res)){
  chunk <- dbFetch(res, n = 300)
  print(nrow(chunk))
}
dbClearResult(res)

```


## How to use parameters (safely) in SQL queries

`dbSendQuery()` can be used with parameterised SQL queries.
For a single set of parameters, the `params` argument can be used. 
It takes a list and its members are substituted in order for the placeholders within the query.
To avoid SQL injection attacks from user-supplied parameters, parameters must always be quoted to ensure they are valid string literals.
This is performed using the function `dbQuoteString()`.

In cases where users may be supplying table or column names to use in the query for data retrieval, those names, or identifiers, must also be escaped. 
As there may be DBMS-specific rules for escaping these identifiers, DBI provides the function `dbQuoteIdentifier()` to generate a safe string representation.

```{r quote}

safe_id <- dbQuoteIdentifier(con,"rating")
safe_param <- dbQuoteLiteral(con,'G')
query <- paste0("SELECT title, ", safe_id, " FROM film WHERE ", safe_id, " = ", safe_param )
res <- dbSendQuery(con, query)
dbFetch(res)
dbClearResult(res)

```

The same result can be had by using `glue::glue_sql()`.
It performs the same safe quoting on any variable or R statement appearing between braces within the query string.

```{r}
id <- "rating"
param <- "G"
query <- glue::glue_sql("SELECT title, {`id`} FROM film WHERE {`id`} = {param}", .con = con)
dbGetQuery(con, query)
```

Rather than performing the parameter substitution ourselves, we can push it to the DBMS by including placeholders in the query.
Different DBMS use different placeholder schemes. MariaDB uses a `?` for each parameter and expects an ordered list of literal values for each placeholder in the query.

Other DBMS may use named parameters. 
Currently there is no list of which placeholder scheme a particular DBMS supports. 
For now all we can recommend is consulting the documention for the DBMS driver you are using.

```{r params}

params <- list( 'G' )
safe_id <- dbQuoteIdentifier(con,"rating")
query <- paste("SELECT * FROM film WHERE ", safe_id, " = ?" )
res <- dbSendQuery(con, query , params = params )
dbFetch(res)
dbClearResult(res)

```

Below is an example query using multiple placeholders with the MariaDB driver.
The placeholders are supplied as a list of values ordered to match the position of the placeholders in the query. 

```{r multi-param}

q_params <- list( 'G', 90 )
query <- paste("SELECT title, rating, length FROM film WHERE rating = ? and length >= ?" )
res <- dbSendQuery(con, query , params = q_params )
dbFetch(res)
dbClearResult(res)


```


When you wish to perform the same query with different sets of parameter values, `dbBind()` is used.
There are two ways to use `dbBind()`.
Firstly, it can be used multiple times with same query.

```{r dbbind}
res <- dbSendQuery(con, "SELECT * FROM film WHERE rating = ?")
dbBind(res, list( 'G' ))
df <- dbFetch(res)
dbBind(res, list( 'PG' ))
df <- dbFetch(res)
dbClearResult(res)

```

Secondly, `dbBind()` can be used to execute the same statement with multiple values at once.

```{r bind_quotestring}
res <- dbSendQuery(con, "SELECT * FROM film WHERE rating = ?")
dbBind(res, list(c("G", "PG")))
df <- dbFetch(res)
dbClearResult(res)
dbDisconnect(con)
```

## SQL data manipulation - UPDATE, DELETE and friends

For SQL queries that affect the underlying database, such as UPDATE, DELETE, INSERT INTO, and DROP TABLE, DBI provides two functions. 
`dbExecute()` passes the SQL statement to the DBMS for execution and returns the number of rows affected.
`dbSendStatement()` performs in the same manner, but returns a result object.
Call `dbGetRowsAffected()` with the result object to get the count of the affected rows. 
You then need to call `dbClearResult()` with the result object afterwards to release resources.

In actuality, `dbExecute()` is a convenience function that calls `dbSendStatement()`, `dbGetRowsAffected()`, and `dbClearResult()`.
You can use these functions if you need more control over the query process.  


```{r}
library(DBI)
con <- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cars", head(cars, 3))

dbExecute(
  con,
  "INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)"
)

rs <- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (4, 4), (5, 5), (6, 6)"
)
dbGetRowsAffected(rs)
dbClearResult(rs)
dbDisconnect(con)
```

## SQL transactions with DBI

DBI allows you to group multiple queries into a single atomic transaction. Transactions are initiated with `dbBegin()` and either made persistent with `dbCommit()` or undone with `dbRollback()`.

```{r}
con <- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cash", data.frame(amount = 100))
dbWriteTable(con, "account", data.frame(amount = 2000))

# All operations are carried out as logical unit:
dbBegin(con)
withdrawal <- 300
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
dbCommit(con)

dbReadTable(con, "cash")
dbReadTable(con, "account")

# Rolling back after detecting negative value on account:
dbBegin(con)
withdrawal <- 5000
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
if (dbReadTable(con, "account")$amount >= 0) {
  dbCommit(con)
} else {
  dbRollback(con)
}

dbReadTable(con, "cash")
dbReadTable(con, "account")

dbDisconnect(con)
```

## Conclusion

That concludes the major features of DBI. 
For more details on the library functions covered in this tutorial and the [Introduction to DBI](missinglink) tutorial see [the DBI specification](https://cran.r-project.org/web/packages/DBI/vignettes/spec.html).
If you are after a data manipulation library that works at a higher level of abstraction, check out [dplyr](https://dplyr.tidyverse.org).
It is a grammar of data manipulation that can work with local dataframes and remote databases and is built upon DBI.
